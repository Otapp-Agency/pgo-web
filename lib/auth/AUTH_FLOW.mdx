# Authentication & Authorization Flow - Real-World Examples

This document explains how the authentication and authorization system works using real-world scenarios.

---

## Table of Contents

1. [Overview](#overview)
2. [Complete Flow Diagram](#complete-flow-diagram)
3. [Scenario 1: User Login](#scenario-1-user-login)
4. [Scenario 2: Accessing Protected Route](#scenario-2-accessing-protected-route)
5. [Scenario 3: Permission Check in Server Component](#scenario-3-permission-check-in-server-component)
6. [Scenario 4: Conditional UI Rendering](#scenario-4-conditional-ui-rendering)
7. [Scenario 5: Multiple Permissions Check](#scenario-5-multiple-permissions-check)
8. [Scenario 6: User Type Validation](#scenario-6-user-type-validation)
9. [Architecture Overview](#architecture-overview)

---

## Overview

The system uses a **two-layer security model**:

1. **Authentication Layer** (`proxy.ts`) - Checks if user is logged in
2. **Authorization Layer** (Server Components/Components) - Checks if user has specific permissions

This separation allows:
- Fast route-level protection (authentication only)
- Fine-grained feature-level protection (permissions)

---

## Complete Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER REQUESTS PAGE                           â”‚
â”‚                    /merchants                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: PROXY MIDDLEWARE (proxy.ts)                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  1. Extract path: /merchants                                    â”‚
â”‚  2. Check if public route? NO                                  â”‚
â”‚  3. Get session from cookie                                     â”‚
â”‚  4. Validate session exists & not expired                      â”‚
â”‚  5. âœ… Session valid â†’ Allow request                            â”‚
â”‚                                                                  â”‚
â”‚  Result: Request proceeds to Next.js                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: SERVER COMPONENT (app/merchants/page.tsx)              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  1. Call: await requirePermission(PERMISSIONS.MERCHANTS.VIEW)   â”‚
â”‚  2. getValidatedSession() helper:                               â”‚
â”‚     - Gets session from cookie                                   â”‚
â”‚     - Validates roles exist                                     â”‚
â”‚     - Validates roles match user type                           â”‚
â”‚  3. Check: hasAnyPermission(roles, 'merchants.view', userType) â”‚
â”‚  4. âœ… Permission granted â†’ Render page                         â”‚
â”‚                                                                  â”‚
â”‚  Result: Page renders with merchant data                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: CLIENT COMPONENT (merchants-table.tsx)                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  1. Get user roles from session                                 â”‚
â”‚  2. Use <Permission> component:                                â”‚
â”‚     - Checks: usePermission(roles, {permission: 'merchants.create'})â”‚
â”‚     - Returns boolean                                           â”‚
â”‚  3. âœ… Has permission â†’ Show "Create Merchant" button          â”‚
â”‚                                                                  â”‚
â”‚  Result: User sees UI elements they can access                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Scenario 1: User Login

**User:** Sarah (System Administrator)  
**Action:** Logs into the application

### Step-by-Step Flow

#### 1. User Submits Credentials
```typescript
// User enters username: "sarah.admin" and password: "SecurePass123!"
// Frontend calls tRPC login mutation
```

#### 2. API Authentication (`lib/auth/dal/api.dal.ts`)
```typescript
// authenticateUser() function:
// - Sends POST request to /api/auth/login
// - Receives response:
{
  status: true,
  data: {
    token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    id: "user-123",
    username: "sarah.admin",
    name: "Sarah Johnson",
    email: "sarah@company.com",
    roles: ["System Administrator"],  // Display name from API
    userType: "SYSTEM_USER",
    requirePasswordChange: false
  }
}
```

#### 3. Role Normalization (`lib/auth/services/auth.service.ts`)
```typescript
// login() function normalizes roles:
const rawRoles = ["System Administrator"]
const normalizedRoles = normalizeRoles(rawRoles)
// Result: ["SYSTEM_ADMIN"]  // Converted to role code
```

#### 4. Session Creation (`lib/auth/services/auth.service.ts`)
```typescript
// createSession() function:
const sessionData = {
  userId: "user-123",
  token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  username: "sarah.admin",
  roles: ["SYSTEM_ADMIN"],  // Normalized role codes
  userType: "SYSTEM_USER",
  // ... other fields
}

// Encrypts and stores in HTTP-only cookie
```

#### 5. Session Cookie Set
```
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        (encrypted JWT containing all session data)
```

**Result:** User is logged in, session cookie is set, user redirected to `/dashboard`

---

## Scenario 2: Accessing Protected Route

**User:** Sarah (System Administrator)  
**Action:** Navigates to `/merchants` page

### Step-by-Step Flow

#### 1. Request Hits Proxy Middleware (`proxy.ts`)
```typescript
// proxy() function receives request:
const path = "/merchants"
const isPublicRoute = false  // Not in publicRoutes array

// Get session from cookie
const session = await getValidSession(req)
// Returns: {
//   userId: "user-123",
//   roles: ["SYSTEM_ADMIN"],
//   userType: "SYSTEM_USER",
//   expiresAt: 1234567890000
// }

// Check if session is valid
if (!session) {
  return NextResponse.redirect('/login')  // Not logged in
}

// âœ… Session valid â†’ Allow request to proceed
return NextResponse.next()
```

**Result:** Request proceeds to Next.js Server Component

#### 2. Server Component Checks Permission (`app/merchants/page.tsx`)
```typescript
export default async function MerchantsPage() {
  // This function calls requirePermission()
  await requirePermission(PERMISSIONS.MERCHANTS.VIEW)
  
  // requirePermission() flow:
  // 1. getValidatedSession() helper:
  //    - Gets session from cookie âœ…
  //    - Checks roles exist âœ…
  //    - Validates roles match userType âœ…
  //    - Returns session object
  
  // 2. hasAnyPermission(["SYSTEM_ADMIN"], "merchants.view", "SYSTEM_USER"):
  //    - Normalizes roles: ["SYSTEM_ADMIN"] âœ…
  //    - Filters by userType: ["SYSTEM_ADMIN"] âœ…
  //    - Checks ROLE_PERMISSIONS["SYSTEM_ADMIN"]:
  //      Contains: ["users.*", "roles.*", "payment_gateways.*", 
  //                 "audit_and_logs.view", "transactions.view", 
  //                 "disbursements.view", "merchants.view"] âœ…
  //    - Finds "merchants.view" âœ…
  //    - Returns true
  
  // 3. Permission granted â†’ Page renders
  
  return <MerchantsTable />
}
```

**Result:** Page renders successfully

---

## Scenario 3: Permission Check in Server Component

**User:** John (Merchant User with MERCHANT_USER role)  
**Action:** Tries to access `/users` page (requires SYSTEM_USER)

### Step-by-Step Flow

#### 1. Proxy Middleware (`proxy.ts`)
```typescript
// Session check passes âœ…
// User is authenticated, request proceeds
```

#### 2. Server Component Permission Check (`app/users/page.tsx`)
```typescript
export default async function UsersPage() {
  await requirePermission(PERMISSIONS.USERS.VIEW)
  
  // requirePermission() flow:
  // 1. getValidatedSession():
  //    - Session: { roles: ["MERCHANT_USER"], userType: "MERCHANT_USER" } âœ…
  
  // 2. hasAnyPermission(["MERCHANT_USER"], "users.view", "MERCHANT_USER"):
  //    - Checks ROLE_PERMISSIONS["MERCHANT_USER"]:
  //      Contains: ["merchants.view", "transactions.view", "disbursements.view"]
  //    - Does NOT contain "users.view" âŒ
  //    - Returns false
  
  // 3. Permission denied â†’ redirect('/unauthorized')
}
```

**Result:** User redirected to `/unauthorized` page

---

## Scenario 4: Conditional UI Rendering

**User:** Sarah (System Administrator)  
**Action:** Views merchants page, sees "Create Merchant" button

### Step-by-Step Flow

#### 1. Server Component Renders (`app/merchants/page.tsx`)
```typescript
export default async function MerchantsPage() {
  await requirePermission(PERMISSIONS.MERCHANTS.VIEW)
  
  const session = await getSession()
  
  return (
    <div>
      <h1>Merchants</h1>
      
      {/* Client Component */}
      <MerchantActions roles={session?.roles} userType={session?.userType} />
      
      <MerchantsTable />
    </div>
  )
}
```

#### 2. Client Component Uses Permission Hook (`components/merchant-actions.tsx`)
```typescript
'use client'

export function MerchantActions({ roles, userType }) {
  return (
    <div>
      {/* Permission component checks access */}
      <Permission 
        roles={roles} 
        permission={PERMISSIONS.MERCHANTS.CREATE}
        userType={userType}
      >
        <button>Create Merchant</button>
      </Permission>
      
      {/* Permission component flow:
          1. usePermission(roles, {permission: "merchants.create"}, userType)
          2. hasAnyPermission(["SYSTEM_ADMIN"], "merchants.create", "SYSTEM_USER")
          3. Checks ROLE_PERMISSIONS["SYSTEM_ADMIN"]
          4. Contains "merchants.view" but NOT "merchants.create" âŒ
          5. Wait... SYSTEM_ADMIN has "merchants.*" which matches!
          6. Wildcard check: "merchants.*" matches "merchants.create" âœ…
          7. Returns true â†’ Button renders
      */}
    </div>
  )
}
```

**Result:** "Create Merchant" button is visible to Sarah

---

## Scenario 5: Multiple Permissions Check

**User:** Mike (Finance Administrator)  
**Action:** Tries to access advanced transaction editor (requires VIEW + UPDATE)

### Step-by-Step Flow

#### Server Component (`app/transactions/[id]/edit/page.tsx`)
```typescript
export default async function EditTransactionPage({ params }) {
  // Requires BOTH permissions (AND logic)
  await requireAllPermissions([
    PERMISSIONS.TRANSACTIONS.VIEW,
    PERMISSIONS.TRANSACTIONS.UPDATE
  ])
  
  // requireAllPermissions() flow:
  // 1. getValidatedSession():
  //    - Session: { roles: ["FINANCE_ADMIN"], userType: "SYSTEM_USER" } âœ…
  
  // 2. Check each permission:
  //    - hasAnyPermission(["FINANCE_ADMIN"], "transactions.view", "SYSTEM_USER")
  //      ROLE_PERMISSIONS["FINANCE_ADMIN"] contains "transactions.*" âœ…
  //    - hasAnyPermission(["FINANCE_ADMIN"], "transactions.update", "SYSTEM_USER")
  //      ROLE_PERMISSIONS["FINANCE_ADMIN"] contains "transactions.*" âœ…
  
  // 3. Both permissions granted â†’ Page renders
  
  return <TransactionEditor />
}
```

**Result:** Page renders successfully

---

## Scenario 6: User Type Validation

**User:** Alice (Merchant User)  
**Action:** System tries to assign SYSTEM_ADMIN role (prevented by validation)

### Step-by-Step Flow

#### Role Assignment Attempt
```typescript
// Someone tries to assign SYSTEM_ADMIN role to Alice
const userRoles = ["SYSTEM_ADMIN"]
const userType = "MERCHANT_USER"

// Validation happens in getValidatedSession():
const validation = validateRolesForUserType(userRoles, userType)
// Checks USER_TYPE_ROLES["MERCHANT_USER"]:
//   Valid roles: ["MERCHANT_ADMIN", "MERCHANT_USER", 
//                "MERCHANT_FINANCE", "MERCHANT_SUPPORT"]
//   "SYSTEM_ADMIN" is NOT in valid roles âŒ
//   Returns: { isValid: false, invalidRoles: ["SYSTEM_ADMIN"] }

// getValidatedSession() returns null
// Permission checks fail â†’ Access denied
```

#### Permission Check with Invalid Role
```typescript
// Even if invalid role somehow gets into session:
const roles = ["SYSTEM_ADMIN", "MERCHANT_USER"]
const userType = "MERCHANT_USER"

// hasAnyPermission() filters roles first:
let normalizedRoles = normalizeRoles(roles)  // ["SYSTEM_ADMIN", "MERCHANT_USER"]
normalizedRoles = filterValidRoles(normalizedRoles, userType)
// Result: ["MERCHANT_USER"]  // SYSTEM_ADMIN filtered out

// Only valid roles are checked for permissions
// SYSTEM_ADMIN permissions are ignored
```

**Result:** Role escalation prevented, only valid roles are used for permission checks

---

## Architecture Overview

### File Structure

```
lib/auth/
â”œâ”€â”€ dal/
â”‚   â”œâ”€â”€ api.dal.ts          # External API calls
â”‚   â””â”€â”€ session.dal.ts      # Cookie encryption/decryption
â”œâ”€â”€ services/
â”‚   â””â”€â”€ auth.service.ts     # Business logic (login, logout, session)
â”œâ”€â”€ permissions.ts          # RBAC engine (roles â†’ permissions)
â”œâ”€â”€ user-types.ts           # User type validation
â”œâ”€â”€ auth.ts                 # Server-side permission helpers
â””â”€â”€ types.ts                # TypeScript types

proxy.ts                    # Authentication middleware (route protection)
hooks/use-permission.ts     # Client-side permission hooks
components/permission.tsx   # Client-side permission component
```

### Key Functions

#### Authentication (Who are you?)
- `proxy.ts` â†’ Checks if user has valid session cookie
- `auth.service.ts` â†’ Creates/validates sessions
- `session.dal.ts` â†’ Encrypts/decrypts session cookies

#### Authorization (What can you do?)
- `permissions.ts` â†’ Maps roles to permissions
- `user-types.ts` â†’ Validates roles match user type
- `auth.ts` â†’ Server-side permission checks
- `use-permission.ts` â†’ Client-side permission checks
- `components/permission.tsx` â†’ Conditional UI rendering

### Permission Check Flow

```
User Request
    â”‚
    â”œâ”€â†’ proxy.ts (Authentication)
    â”‚   â””â”€â†’ Valid session? âœ… â†’ Continue
    â”‚       âŒ â†’ Redirect to /login
    â”‚
    â””â”€â†’ Server Component (Authorization)
        â”œâ”€â†’ requirePermission()
        â”‚   â”œâ”€â†’ getValidatedSession()
        â”‚   â”‚   â”œâ”€â†’ verifySession() âœ…
        â”‚   â”‚   â”œâ”€â†’ Validate roles exist âœ…
        â”‚   â”‚   â””â”€â†’ Validate roles match userType âœ…
        â”‚   â”‚
        â”‚   â””â”€â†’ hasAnyPermission()
        â”‚       â”œâ”€â†’ normalizeRoles() â†’ ["SYSTEM_ADMIN"]
        â”‚       â”œâ”€â†’ filterValidRoles() â†’ ["SYSTEM_ADMIN"]
        â”‚       â””â”€â†’ Check ROLE_PERMISSIONS â†’ âœ… or âŒ
        â”‚
        â””â”€â†’ Permission granted? âœ… â†’ Render page
            âŒ â†’ Redirect to /unauthorized
```

### Role Hierarchy Example

```
SYSTEM_USER (userType)
â”œâ”€â”€ SYSTEM_ADMIN
â”‚   â””â”€â”€ Permissions: users.*, roles.*, payment_gateways.*, merchants.view, ...
â”œâ”€â”€ FINANCE_ADMIN
â”‚   â””â”€â”€ Permissions: transactions.*, disbursements.*, merchants.view, ...
â””â”€â”€ PAYMENT_OPERATOR
    â””â”€â”€ Permissions: transactions.view, transactions.update_status, ...

MERCHANT_USER (userType)
â”œâ”€â”€ MERCHANT_ADMIN
â”‚   â””â”€â”€ Permissions: merchants.view, merchants.update, transactions.view, ...
â”œâ”€â”€ MERCHANT_USER
â”‚   â””â”€â”€ Permissions: merchants.view, transactions.view, disbursements.view
â””â”€â”€ MERCHANT_FINANCE
    â””â”€â”€ Permissions: merchants.view, transactions.view, transactions.export, ...
```

---

## Common Patterns

### Pattern 1: Protect Entire Page
```typescript
// app/admin/users/page.tsx
export default async function AdminUsersPage() {
  await requirePermission(PERMISSIONS.USERS.VIEW)
  // Page only renders if user has permission
  return <UsersList />
}
```

### Pattern 2: Protect Server Action
```typescript
// app/actions/merchants.ts
'use server'

export async function createMerchant(data: FormData) {
  await requirePermission(PERMISSIONS.MERCHANTS.CREATE)
  // Action only executes if user has permission
  // ... create merchant logic
}
```

### Pattern 3: Conditional UI Element
```typescript
// components/user-actions.tsx
'use client'

export function UserActions({ roles, userType }) {
  return (
    <>
      <Permission roles={roles} permission={PERMISSIONS.USERS.CREATE} userType={userType}>
        <button>Create User</button>
      </Permission>
      
      <Permission roles={roles} permission={PERMISSIONS.USERS.DELETE} userType={userType}>
        <button>Delete User</button>
      </Permission>
    </>
  )
}
```

### Pattern 4: Multiple Permissions (OR)
```typescript
// User needs ANY of these permissions
await requireAnyPermission([
  PERMISSIONS.TRANSACTIONS.VIEW,
  PERMISSIONS.TRANSACTIONS.UPDATE
])
```

### Pattern 5: Multiple Permissions (AND)
```typescript
// User needs ALL of these permissions
await requireAllPermissions([
  PERMISSIONS.USERS.VIEW,
  PERMISSIONS.USERS.UPDATE
])
```

---

## Security Features

### 1. Role Escalation Prevention
- User types restrict which roles can be assigned
- Invalid roles are filtered out automatically
- Validation happens at multiple layers

### 2. Session Security
- Sessions stored in HTTP-only cookies
- Encrypted using JWT with secret key
- Automatic expiration checking

### 3. Defense in Depth
- Route-level protection (proxy.ts)
- Component-level protection (requirePermission)
- UI-level protection (Permission component)

### 4. Wildcard Permissions
- `users.*` matches `users.create`, `users.update`, etc.
- Simplifies role definitions
- Super admin has `*` (all permissions)

---

## Troubleshooting

### Issue: User can't access page they should have access to

**Check:**
1. Does user have valid session? (Check browser cookies)
2. Does user's role have the required permission? (Check ROLE_PERMISSIONS)
3. Does role match user type? (Check USER_TYPE_ROLES)
4. Is permission string correct? (Check PERMISSIONS constants)

### Issue: User sees UI elements they shouldn't

**Check:**
1. Are roles passed correctly to Permission component?
2. Is userType passed to Permission component?
3. Are permission strings matching exactly?

### Issue: Session expires too quickly

**Check:**
1. SESSION.EXPIRY_MS in constants
2. JWT expiration time in session.dal.ts
3. Cookie expiration in session.dal.ts

---

## Best Practices

1. **Always use permission constants** - Don't hardcode strings
   ```typescript
   // âœ… Good
   await requirePermission(PERMISSIONS.USERS.CREATE)
   
   // âŒ Bad
   await requirePermission('users.create')
   ```

2. **Check permissions early** - In Server Components, check at the start
   ```typescript
   // âœ… Good
   export default async function Page() {
     await requirePermission(PERMISSIONS.USERS.VIEW)
     // ... rest of component
   }
   ```

3. **Pass userType to client components** - Always pass userType for proper validation
   ```typescript
   // âœ… Good
   <Permission roles={roles} permission={perm} userType={userType} />
   ```

4. **Use appropriate check type** - Choose between requirePermission (throws) and checkPermission (returns boolean)
   ```typescript
   // âœ… For pages/actions (throws redirect)
   await requirePermission(PERMISSIONS.USERS.VIEW)
   
   // âœ… For conditional logic (returns boolean)
   const canEdit = await checkPermission(PERMISSIONS.USERS.UPDATE)
   ```

---

## Summary

The authentication and authorization system provides:

- **Fast route protection** via proxy middleware (authentication only)
- **Fine-grained control** via permission checks in components
- **Type-safe** permission constants
- **Secure** role validation preventing escalation
- **Simple** unified API for both server and client

All while maintaining **~40% less code** than before! ğŸ‰

